package population.sv.preprocess.filter;

import java.nio.file.Path;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Stream;

import htsjdk.variant.variantcontext.VariantContext;
import htsjdk.variant.variantcontext.writer.Options;
import htsjdk.variant.variantcontext.writer.VariantContextWriter;
import htsjdk.variant.variantcontext.writer.VariantContextWriterBuilder;
import htsjdk.variant.vcf.VCFFileReader;
import htsjdk.variant.vcf.VCFHeader;
import population.vcf.utils.SVVcfUtils;

/**
 * 
 * filter out SVs in a vcf file generated by lumpy
 * 		the SV vcf file should be 
 * 			1. BND type SV filtered out
 * 			2. all SVs have been genotyped by SVTyper, thus the QUAL column has been assigned values
 * 
 * one output vcf files will be generated:
 * 1. all SVs with both length and QUAL score qualified (IMPRECISE + PRECISE)
 * 
 * 2. all 'PRECISE' SVs with both length and QUAL score qualified
 * 
 * ==============================
 * input vcf file contains only the common SV types (DEL, INV, DUP, INS)
 * input vcf file should contains the reference dictionary infor in the header section as following
 * 		
 * 		##reference=/scratch/tanxu/reseq/sb/reference/v3.1.1/assembly/Sbicolor_454_v3.0.1.fa
		##contig=<ID=Chr01,length=80884392>
		##contig=<ID=Chr02,length=77742459>
		##contig=<ID=Chr03,length=74386277>
		##contig=<ID=Chr04,length=68658214>
		##contig=<ID=Chr05,length=71854669>
		##contig=<ID=Chr06,length=61277060>
		... ...
 * 
 * ===============================
 * filter strategies:
 * 
 * 1. filter out SV with SV length > {@link #maxSVLen}
 *  	note that some length will be negative (start-end), thus need to use the absolute value
 * 
 * 2. filter out SV with QUAL column < {@link #minQual}
 * 		note that the QUAL column is calculated by SVTyper, while the 'IMPRECISE' attribute in INFO column is assigned by LUMPY caller
 * 
 * 3. filter out SV with (CIPOS+CIEND)/abs(SVLen) < {@link #maxBoundaryUncertainty}
 * 		for example, for a 'IMPRECISE' SV with 
 * 			CIEND=0,7;CIPOS=-5,1;SVLEN=84
 * 		this value is calculated as (7-0 + 1+5)/84=13/84 <50%, kept
 * 	note that some SV's 'SVLen' attribute in INFO column may be negative, thus, need to use the absolute value
 * 
 * @author tanxu
 *
 */
public class LumpySVVCFFilter {
	static int filteredByLEN=0;
	static int filteredByQual=0;
	static int filteredByBoundaryUncertainty=0;
	
	////////////////////////////////
	/**
	 * sv vcf file generated by LUMPY and genotyped by SVTyper;
	 * 
	 * should contains the reference dictionary infor in the header section as following
	 * 
	 * 	##reference=/scratch/tanxu/reseq/sb/reference/v3.1.1/assembly/Sbicolor_454_v3.0.1.fa
		##contig=<ID=Chr01,length=80884392>
		##contig=<ID=Chr02,length=77742459>
		##contig=<ID=Chr03,length=74386277>
		##contig=<ID=Chr04,length=68658214>
		##contig=<ID=Chr05,length=71854669>
		##contig=<ID=Chr06,length=61277060>
	 */
	private final Path inputVCFFile;
	/**
	 * max allowed SV length to be included in output VCF file
	 */
	private final int maxSVLen;
	/**
	 * minimal allowed QUAL score value for SV to be included in output VCF file;
	 */
	private final double minQual;
	
	/**
	 * max allowed value of (CIPOS+CIEND)/abs(SVLen) for a 'IMPRECISE' SV to be included in output VCF file
	 * 
	 * for example, for a 'IMPRECISE' SV with 
	 * 			CIEND=0,7;CIPOS=-5,1;SVLEN=84
	 * 		this value is calculated as (7-0 + 1+5)/84=13/84 
	 */
	private final double maxBoundaryUncertainty;
	
	/**
	 * 
	 */
	private final Path outputVCFFile;
	
	///////////////////
	private VCFFileReader inputVCFReader;
	private VariantContextWriter writer;
	private Map<String, Integer> svTypeNumMap;
	
	public LumpySVVCFFilter(
			Path inputVCFFile, 
			int maxSVLen, double minQual, double maxBoundaryUncertainty,
			Path outputVCFFile) {
		super();
		this.inputVCFFile = inputVCFFile;
		this.maxSVLen = maxSVLen;
		this.minQual = minQual;
		this.maxBoundaryUncertainty = maxBoundaryUncertainty;
		this.outputVCFFile = outputVCFFile;
		
		if(this.outputVCFFile.toFile().exists()) {
			System.out.println("outputVCFFile already exists, delete it...");
			this.outputVCFFile.toFile().delete();
		}
		
		/////////////////////////
		this.prepareOutVCF();
		this.run();
		this.report();
	}

	/**
	 * write the header section to output vcf file with the header section of input vcf file
	 */
	void prepareOutVCF() {
		System.out.println("write out the header section of output vcf file...");
		this.inputVCFReader = new VCFFileReader(this.inputVCFFile, false);
		//////////
		VariantContextWriterBuilder builder = 
				new VariantContextWriterBuilder().setOutputFile(this.outputVCFFile.toFile())
				.setReferenceDictionary(this.inputVCFReader.getFileHeader().getSequenceDictionary()).setOption(Options.ALLOW_MISSING_FIELDS_IN_HEADER);
		
		this.writer =builder.build();
		
		/////////////////modify the header (line containing the sample names)
		
		VCFHeader header = this.inputVCFReader.getHeader();
		this.writer.writeHeader(header); //write the header section of the vcf file
		
		this.inputVCFReader.close();
	}
	
	/**
	 * read the input vcf files one by one and filter out duplicate SVs
	 */
	void run() {
		System.out.println("check each SV ...");
		this.svTypeNumMap=new HashMap<>();
		
		this.inputVCFReader = new VCFFileReader(this.inputVCFFile, false);
		////////////////process each locus
		Stream<VariantContext> stream=this.inputVCFReader.iterator().stream();
		stream.forEach(vc->{
			int POS = vc.getStart();
			Integer END=vc.getAttribute("END")==null?null:Integer.parseInt((String)vc.getAttribute("END")); //GRIDSS does not use END attribute its INFO column since every breakend mate pairs are put in two separate lines;
			if(POS>END) {
				System.out.println("POS>END!");
			}
			double qualScore=vc.getPhredScaledQual();
			//if 'IMPRECISE' is absent, the attribute value will be 'null' rather than false
			Boolean IMPRECISE=vc.getAttribute("IMPRECISE")==null?false:(Boolean) vc.getAttribute("IMPRECISE"); //note that LUMPY does not use PRECISE attribute to indicate precise SV;
			Integer SVLEN=vc.getAttribute("SVLEN")==null?null:Integer.parseInt((String)vc.getAttribute("SVLEN")); //GRIDSS does not use END attribute its INFO column since every breakend mate pairs are put in two separate lines;
			String SVTYPE=(String)vc.getAttribute("SVTYPE"); //all records are BND type for gridss
			List<Integer> CIPOS=SVVcfUtils.getCIPOSCIENDAttributeValues(vc.getAttribute("CIPOS")); //only present for mated breakend pairs; not present for single breakend
			//##INFO=<ID=CIEND,Number=2,Type=Integer,Description="Confidence interval around END for imprecise variants">
			List<Integer> CIEND=SVVcfUtils.getCIPOSCIENDAttributeValues(vc.getAttribute("CIEND")); //GRIDSS does not use CIEND attribute in its INFO column since every breakend mate pairs are put in two separate lines;
			
//			System.out.println(CIPOS.get(0).toString()+"\t"+CIPOS.get(0).getClass().getName());
			double CIPOSRange=Math.abs(CIPOS.get(0)-CIPOS.get(1));
			double CIENDRange=Math.abs(CIEND.get(0)-CIEND.get(1));
			
			//
			if(Math.abs(SVLEN)>this.maxSVLen 
					|| qualScore<this.minQual 
					|| IMPRECISE && (CIPOSRange+CIENDRange)/SVLEN>this.maxBoundaryUncertainty) {
				//filtered
				if(Math.abs(SVLEN)>this.maxSVLen )
					LumpySVVCFFilter.filteredByLEN++;
				if(qualScore<this.minQual)
					LumpySVVCFFilter.filteredByQual++;
				
				if(IMPRECISE && (CIPOSRange+CIENDRange)/SVLEN>this.maxBoundaryUncertainty)
					LumpySVVCFFilter.filteredByBoundaryUncertainty++;
				
			}else {//qualified
				this.writer.add(vc);
				
				if(!this.svTypeNumMap.containsKey(SVTYPE)) {
					this.svTypeNumMap.put(SVTYPE, 0);
				}
				this.svTypeNumMap.put(SVTYPE, this.svTypeNumMap.get(SVTYPE)+1);
			}
		});
		
		this.inputVCFReader.close();
		
		this.writer.close();
	}
	
	void report() {
		System.out.println("filtered out by SVLen:"+LumpySVVCFFilter.filteredByLEN);
		System.out.println("filtered out by QUAL:"+LumpySVVCFFilter.filteredByQual);
		System.out.println("filtered out by BoundaryUncertainty:"+LumpySVVCFFilter.filteredByBoundaryUncertainty);
		
		////////////
		System.out.println("qualified SVs:");
		this.svTypeNumMap.forEach((k,v)->{
			System.out.println(k+"\t"+v);
		});
	}
}
