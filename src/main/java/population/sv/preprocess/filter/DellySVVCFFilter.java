package population.sv.preprocess.filter;

import java.nio.file.Path;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Stream;

import htsjdk.variant.variantcontext.VariantContext;
import htsjdk.variant.variantcontext.writer.Options;
import htsjdk.variant.variantcontext.writer.VariantContextWriter;
import htsjdk.variant.variantcontext.writer.VariantContextWriterBuilder;
import htsjdk.variant.vcf.VCFFileReader;
import htsjdk.variant.vcf.VCFHeader;
import population.vcf.utils.SVVcfUtils;

/**
 * filter out SVs in a vcf file generated by delly
 * 		the VCF file generated by delly pipeline
 * 
 * all SVs not filtered out will be output to a new vcf file
 * 
 * ======================================
 * input vcf file contains only the common SV types (DEL, INV, DUP, INS)
 * input vcf file should contains the reference dictionary infor in the header section as following
 * 
 * 		##reference=/scratch/tanxu/reseq/sb/reference/v3.1.1/assembly/Sbicolor_454_v3.0.1.fa
		##contig=<ID=Chr01,length=80884392>
		##contig=<ID=Chr02,length=77742459>
		##contig=<ID=Chr03,length=74386277>
		##contig=<ID=Chr04,length=68658214>
		##contig=<ID=Chr05,length=71854669>
		##contig=<ID=Chr06,length=61277060>
 * =======================================
 * filter strategies:
 * 1. filter out all breakend type SV
 * 		SVTYPE=BND
 * 
 * 2. filter SV with length > {@link #maxSVLen}
 *  	note that some length will be negative (start-end), thus need to use the absolute value
 * 
 * 3. filter out SV with 'FILTER' column being 'LowQual'
 * 		'PASS' will be kept
 * 		note that QUAL column is also calculated by DELLY caller, but it is duplicate with the 'FILTER' column, thus, use 'FILTER' column instead
 * 
 * 4. filter out SV with (CIPOS+CIEND)/abs(SVLen) < {@link #maxBoundaryUncertainty}
 * 		for example, for a 'IMPRECISE' SV with length 84
 * 			CIEND=0,7;CIPOS=-5,1
 * 		this value is calculated as (7-0 + 1+5)/84=13/84 <50%, kept
 * 	note that for DELLY's sv vcf output file, there is no 'SVLen' attribute in the INFO column, thus it should be calculated from the 'pos' and 'end'
 * 
 * @author tanxu
 *
 */
public class DellySVVCFFilter {
	/**
	 * sv vcf file generated by LUMPY and genotyped by SVTyper;
	 * 
	 * should contains the reference dictionary infor in the header section as following
	 * 
	 * 	##reference=/scratch/tanxu/reseq/sb/reference/v3.1.1/assembly/Sbicolor_454_v3.0.1.fa
		##contig=<ID=Chr01,length=80884392>
		##contig=<ID=Chr02,length=77742459>
		##contig=<ID=Chr03,length=74386277>
		##contig=<ID=Chr04,length=68658214>
		##contig=<ID=Chr05,length=71854669>
		##contig=<ID=Chr06,length=61277060>
	 */
	private final Path inputVCFFile;
	/**
	 * max allowed SV length to be included in output VCF file
	 */
	private final int maxSVLen;
	
	/**
	 * max allowed value of (CIPOS+CIEND)/abs(SVLen) for a 'IMPRECISE' SV to be included in output VCF file
	 * 
	 * for example, for a 'IMPRECISE' SV with 
	 * 			CIEND=0,7;CIPOS=-5,1;SVLEN=84
	 * 		this value is calculated as (7-0 + 1+5)/84=13/84 
	 */
	private final double maxBoundaryUncertainty;
	
	/**
	 * 
	 */
	private final Path outputVCFFile;
	
	///////////////////
	private VCFFileReader inputVCFReader;
	private VariantContextWriter writer;
	private Map<String, Integer> svTypeNumMap;
	
	public DellySVVCFFilter(
			Path inputVCFFile, 
			int maxSVLen, double maxBoundaryUncertainty,
			Path outputVCFFile) {
		super();
		this.inputVCFFile = inputVCFFile;
		this.maxSVLen = maxSVLen;
		this.maxBoundaryUncertainty = maxBoundaryUncertainty;
		this.outputVCFFile = outputVCFFile;
		
		if(this.outputVCFFile.toFile().exists()) {
			System.out.println("outputVCFFile already exists, delete it...");
			this.outputVCFFile.toFile().delete();
		}
		
		/////////////////////////
		this.prepareOutVCF();
		this.run();
		this.report();
	}
	
	/**
	 * write the header section to output vcf file with the header section of input vcf file
	 */
	void prepareOutVCF() {
		System.out.println("write out the header section of output vcf file...");
		this.inputVCFReader = new VCFFileReader(this.inputVCFFile, false);
		//////////
		VariantContextWriterBuilder builder = 
				new VariantContextWriterBuilder().setOutputFile(this.outputVCFFile.toFile())
				.setReferenceDictionary(this.inputVCFReader.getFileHeader().getSequenceDictionary()).setOption(Options.ALLOW_MISSING_FIELDS_IN_HEADER);
		
		this.writer =builder.build();
		
		/////////////////modify the header (line containing the sample names)
		
		VCFHeader header = this.inputVCFReader.getHeader();
		this.writer.writeHeader(header); //write the header section of the vcf file
		
		this.inputVCFReader.close();
	}
	
	/**
	 * read the input vcf files one by one and filter out duplicate SVs
	 */
	void run() {
		System.out.println("check each SV ...");
		this.svTypeNumMap=new HashMap<>();
		
		this.inputVCFReader = new VCFFileReader(this.inputVCFFile, false);
		////////////////process each locus
		Stream<VariantContext> stream=this.inputVCFReader.iterator().stream();
		stream.forEach(vc->{
			int POS = vc.getStart();
			Integer END=vc.getAttribute("END")==null?null:Integer.parseInt((String)vc.getAttribute("END"));
			if(POS>END) {
				System.out.println("POS>END!");
			}
			//if 'IMPRECISE' is absent, the attribute value will be 'null' rather than false
			Boolean IMPRECISE=vc.getAttribute("IMPRECISE")==null?false:(Boolean) vc.getAttribute("IMPRECISE"); //note that LUMPY does not use PRECISE attribute to indicate precise SV;
			//FILTER column
			boolean passed=vc.isNotFiltered();
			//
			String SVTYPE=(String)vc.getAttribute("SVTYPE"); //all records are BND type for gridss
			//
			List<Integer> CIPOS=SVVcfUtils.getCIPOSCIENDAttributeValues(vc.getAttribute("CIPOS")); //only present for mated breakend pairs; not present for single breakend
			//##INFO=<ID=CIEND,Number=2,Type=Integer,Description="Confidence interval around END for imprecise variants">
			List<Integer> CIEND=SVVcfUtils.getCIPOSCIENDAttributeValues(vc.getAttribute("CIEND")); //GRIDSS does not use CIEND attribute in its INFO column since every breakend mate pairs are put in two separate lines;
			
//			System.out.println(CIPOS.get(0).toString()+"\t"+CIPOS.get(0).getClass().getName());
			double CIPOSRange=Math.abs(CIPOS.get(0)-CIPOS.get(1));
			double CIENDRange=Math.abs(CIEND.get(0)-CIEND.get(1));
			
			int len=Math.abs(POS-END)+1;
			//
			if(SVTYPE.equals("BND")
					|| !passed
					|| Math.abs(len)>this.maxSVLen 
					|| IMPRECISE && (CIPOSRange+CIENDRange)/len>this.maxBoundaryUncertainty) {
				//filtered
				if(Math.abs(len)>this.maxSVLen )
					LumpySVVCFFilter.filteredByLEN++;
				if(!passed)
					LumpySVVCFFilter.filteredByQual++;
				
				if(IMPRECISE && (CIPOSRange+CIENDRange)/len>this.maxBoundaryUncertainty)
					LumpySVVCFFilter.filteredByBoundaryUncertainty++;
				
			}else {//qualified
				this.writer.add(vc);
				
				if(!this.svTypeNumMap.containsKey(SVTYPE)) {
					this.svTypeNumMap.put(SVTYPE, 0);
				}
				this.svTypeNumMap.put(SVTYPE, this.svTypeNumMap.get(SVTYPE)+1);
			}
		});
		
		this.inputVCFReader.close();
		
		this.writer.close();
	}
	
	void report() {
		System.out.println("filtered out by SVLen:"+LumpySVVCFFilter.filteredByLEN);
		System.out.println("filtered out by QUAL:"+LumpySVVCFFilter.filteredByQual);
		System.out.println("filtered out by BoundaryUncertainty:"+LumpySVVCFFilter.filteredByBoundaryUncertainty);
		
		////////////
		System.out.println("qualified SVs:");
		this.svTypeNumMap.forEach((k,v)->{
			System.out.println(k+"\t"+v);
		});
	}
}
